# Multi-Offer Procurement Feature

**Generated by:** Gemini (Google)
**Evaluated by:** Claude (Anthropic)
**Date:** 2026-01-30

## Overview

This feature allows procurement to manage 2-5 price offers from different suppliers per quote item and select the best one.

## Files

```
features/procurement-offers-gemini/
‚îú‚îÄ‚îÄ README.md                   # This file
‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îî‚îÄ‚îÄ 145_item_price_offers.sql  # Database migration
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ price_offer_service.py     # Service layer
‚îú‚îÄ‚îÄ routes_price_offers.py         # HTMX route examples
‚îî‚îÄ‚îÄ ui_components.py               # FastHTML UI components
```

## Architecture

**Approach:** Separate `item_price_offers` table with service layer sync

### Database Design

- **Table:** `kvota.item_price_offers`
- **Key constraint:** Partial unique index ensures only one `is_selected=TRUE` per item
- **Atomic selection:** Stored procedure `select_price_offer()` for race-safe selection
- **RLS:** Role-based access (procurement, admin, finance)

### Data Flow

1. Procurement adds offers to `item_price_offers` table
2. Procurement selects best offer (radio button)
3. Service layer syncs selected offer ‚Üí `quote_items` fields
4. Calculation engine reads from `quote_items` (no changes needed)

---

## Claude's Evaluation

### ‚úÖ Strengths

1. **Clean separation of concerns**
   - Offers table is self-contained
   - Service layer handles all business logic
   - UI components are reusable

2. **Atomic selection with stored procedure**
   - `select_price_offer()` prevents race conditions
   - Partial unique index as safety net

3. **Good dataclass pattern**
   - `PriceOffer.from_dict()` handles joined data cleanly
   - Matches existing patterns (supplier_service.py)

4. **Comprehensive RLS policies**
   - All CRUD operations covered
   - Uses `r.slug` correctly (not `r.code`)

5. **HTMX-friendly UI**
   - OOB swaps for seamless updates
   - Collapsible add form
   - Clear visual feedback (selected row highlighting)

### ‚ö†Ô∏è Areas Needing Attention

1. ~~**Sync function race condition**~~ ‚úÖ FIXED
   Gemini's stored procedure includes sync in the same transaction.
   Updated code uses atomic `select_price_offer(offer_id)` that does:
   - Deselect old ‚Üí Select new ‚Üí Sync to quote_items

2. **Critical RLS bug in original Gemini output**
   ```sql
   -- WRONG (in Gemini's output):
   AND r.code IN ('admin', 'procurement')
   -- CORRECT (fixed in saved file):
   AND r.slug IN ('admin', 'procurement')
   ```
   **Status:** Fixed in saved migration file.

3. **Missing validation in routes**
   ```python
   # Should verify item belongs to accessible quote
   # Should check max offers limit (5)
   ```

3. **Error handling sparse**
   - `select_offer()` returns True always
   - No handling if RPC fails

4. **UI currency mismatch**
   - Shows offer currency, but calculation expects normalized price
   - Need clear indication that prices are in different currencies

5. **Migration order**
   - Assumes `kvota.suppliers` table exists
   - Assumes `kvota.migrations` table exists

### üîß Recommended Changes Before Merging

1. **Add transaction to sync:**
   ```python
   def select_and_sync_offer(offer_id: str, quote_item_id: str):
       """Atomic select + sync in one operation."""
       supabase = get_supabase()
       supabase.rpc("select_and_sync_price_offer", {
           "p_offer_id": offer_id,
           "p_quote_item_id": quote_item_id
       }).execute()
   ```

2. **Add max offers check:**
   ```python
   def create_offer(...):
       count = count_offers_for_item(quote_item_id)
       if count >= 5:
           raise ValueError("Maximum 5 offers per item")
   ```

3. **Add authorization check in routes:**
   ```python
   # Verify user can access the quote
   quote_item = supabase.table("quote_items").select("quote_id").eq("id", item_id).execute()
   quote = supabase.table("quotes").select("id").eq("id", quote_item.data[0]["quote_id"]).execute()
   # RLS will handle org check
   ```

### üìä Complexity Assessment

| Aspect | Rating | Notes |
|--------|--------|-------|
| Implementation effort | Medium | ~4-6 hours for full integration |
| Database complexity | Low | Single table + 1 function |
| UI complexity | Medium | New component, HTMX integration |
| Testing effort | Medium | Need to test selection, sync, edge cases |
| Rollback risk | Low | Can drop table without affecting existing data |

### üèÅ Verdict

**Ready for implementation.**

The architecture is sound and follows existing patterns. After incorporating Gemini's atomic stored procedure:
- ‚úÖ Race condition resolved (sync in same transaction)
- ‚úÖ RLS bug fixed (r.slug instead of r.code)
- ‚ö†Ô∏è Still need: max offers limit, authorization checks in routes

The JSONB alternative would be simpler but this approach is more maintainable long-term and provides better query capabilities for reporting.

---

## Integration Checklist

- [ ] Apply migration 145
- [ ] Add `price_offer_service.py` to services/
- [ ] Add routes to main.py
- [ ] Import UI components
- [ ] Add offers section to procurement item card
- [ ] Test: Create offer
- [ ] Test: Select offer (verify sync)
- [ ] Test: Delete selected offer
- [ ] Test: Concurrent selection (race condition)
- [ ] Test: Max 5 offers limit
