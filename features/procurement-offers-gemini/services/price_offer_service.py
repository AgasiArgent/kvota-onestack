"""
Price Offer Service

Manages multiple supplier price offers per quote item.
Allows procurement to compare 2-5 offers and select the best one.

Generated by Gemini, evaluated by Claude
"""

from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from typing import List, Optional
from uuid import UUID

from services.database import get_supabase


@dataclass
class PriceOffer:
    """Represents a supplier price offer for a quote item."""
    id: UUID
    quote_item_id: UUID
    supplier_id: UUID
    price: Decimal
    currency: str
    production_days: int
    is_selected: bool
    notes: Optional[str]
    created_at: datetime
    created_by: Optional[UUID]
    # Joined fields
    supplier_name: Optional[str] = None

    @classmethod
    def from_dict(cls, data: dict) -> "PriceOffer":
        """Create PriceOffer from database row."""
        # Handle joined supplier data
        supplier_name = None
        if "suppliers" in data and data["suppliers"]:
            supplier_name = data["suppliers"].get("name")

        return cls(
            id=UUID(data["id"]),
            quote_item_id=UUID(data["quote_item_id"]),
            supplier_id=UUID(data["supplier_id"]),
            price=Decimal(str(data["price"])),
            currency=data["currency"],
            production_days=data.get("production_days") or 0,
            is_selected=data.get("is_selected", False),
            notes=data.get("notes"),
            created_at=datetime.fromisoformat(data["created_at"].replace("Z", "+00:00")),
            created_by=UUID(data["created_by"]) if data.get("created_by") else None,
            supplier_name=supplier_name,
        )


def get_offers_for_item(quote_item_id: str) -> List[PriceOffer]:
    """
    Get all price offers for a quote item.

    Args:
        quote_item_id: UUID of the quote item

    Returns:
        List of PriceOffer objects, selected first, then by price ascending
    """
    supabase = get_supabase()

    result = supabase.table("item_price_offers") \
        .select("*, suppliers(name)") \
        .eq("quote_item_id", quote_item_id) \
        .order("is_selected", desc=True) \
        .order("price", desc=False) \
        .execute()

    return [PriceOffer.from_dict(row) for row in (result.data or [])]


def get_offer_by_id(offer_id: str) -> Optional[PriceOffer]:
    """
    Get a single price offer by ID.

    Args:
        offer_id: UUID of the offer

    Returns:
        PriceOffer or None if not found
    """
    supabase = get_supabase()

    result = supabase.table("item_price_offers") \
        .select("*, suppliers(name)") \
        .eq("id", offer_id) \
        .limit(1) \
        .execute()

    if not result.data:
        return None

    return PriceOffer.from_dict(result.data[0])


def create_offer(
    quote_item_id: str,
    supplier_id: str,
    price: Decimal,
    currency: str,
    production_days: int = 0,
    notes: Optional[str] = None,
    user_id: Optional[str] = None
) -> PriceOffer:
    """
    Create a new price offer.

    Args:
        quote_item_id: UUID of the quote item
        supplier_id: UUID of the supplier
        price: Price amount
        currency: Currency code (USD, EUR, RUB, etc.)
        production_days: Production time in days
        notes: Optional notes
        user_id: UUID of the user creating the offer

    Returns:
        Created PriceOffer
    """
    supabase = get_supabase()

    data = {
        "quote_item_id": quote_item_id,
        "supplier_id": supplier_id,
        "price": float(price),
        "currency": currency,
        "production_days": production_days,
        "notes": notes,
        "created_by": user_id,
    }

    result = supabase.table("item_price_offers") \
        .insert(data) \
        .execute()

    if not result.data:
        raise ValueError("Failed to create price offer")

    # Fetch with joined supplier name
    return get_offer_by_id(result.data[0]["id"])


def select_offer(offer_id: str) -> bool:
    """
    Select a price offer (deselects all others for same item).
    Uses atomic stored procedure for race condition safety.
    Also syncs selected data to quote_items table.

    Args:
        offer_id: UUID of the offer to select

    Returns:
        True if successful, False on error
    """
    try:
        supabase = get_supabase()
        # Stored procedure handles: deselect old → select new → sync to quote_items
        supabase.rpc("select_price_offer", {"p_offer_id": offer_id}).execute()
        return True
    except Exception as e:
        print(f"Error selecting offer {offer_id}: {e}")
        return False


def delete_offer(offer_id: str) -> bool:
    """
    Delete a price offer.

    Args:
        offer_id: UUID of the offer to delete

    Returns:
        True if deleted, False if not found
    """
    supabase = get_supabase()

    result = supabase.table("item_price_offers") \
        .delete() \
        .eq("id", offer_id) \
        .execute()

    return len(result.data or []) > 0


def get_selected_offer(quote_item_id: str) -> Optional[PriceOffer]:
    """
    Get the currently selected offer for a quote item.

    Args:
        quote_item_id: UUID of the quote item

    Returns:
        Selected PriceOffer or None
    """
    supabase = get_supabase()

    result = supabase.table("item_price_offers") \
        .select("*, suppliers(name)") \
        .eq("quote_item_id", quote_item_id) \
        .eq("is_selected", True) \
        .limit(1) \
        .execute()

    if not result.data:
        return None

    return PriceOffer.from_dict(result.data[0])


def count_offers_for_item(quote_item_id: str) -> int:
    """
    Count offers for a quote item.

    Args:
        quote_item_id: UUID of the quote item

    Returns:
        Number of offers
    """
    supabase = get_supabase()

    result = supabase.table("item_price_offers") \
        .select("id", count="exact") \
        .eq("quote_item_id", quote_item_id) \
        .execute()

    return result.count or 0
