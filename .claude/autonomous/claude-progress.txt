# Claude Progress Log
# Project: OneStack Workflow Extension
# Created: 2025-01-14
# Spec: .claude/autonomous/app_spec.xml

## Project Overview

Расширение существующей системы OneStack (расчёт коммерческих предложений)
для поддержки многоролевого workflow с 9 ролями, уведомлениями через Telegram
и финансовым учётом план-факт.

**Текущее состояние:** Базовая система работает (КП, расчёт, экспорт)
**Цель:** Полный бизнес-процесс от заявки до сделки

## Features to Implement

88 features total across 8 phases:
1. Database Schema (16 features)
2. Role System (6 features)
3. Workflow Engine (10 features)
4. Role-Specific UI - Procurement, Logistics, Customs, Quote Control (19 features)
5. Telegram Bot (15 features)
6. Specifications & Deals (10 features)
7. Plan-Fact Finance (7 features)
8. Admin & Polish (5 features)

## Business Process Summary

1. Sales Manager uploads quote request
2. Procurement Manager(s) evaluate by brand
3. Logistics + Customs work in parallel
4. Sales Manager sets markup and terms
5. Quote Controller (Zhanna) reviews
6. Top Manager approves via Telegram (if needed)
7. Client negotiation, versioning
8. Spec Controller prepares specification
9. Signature → Deal
10. Finance tracks plan vs actual payments

## Key Roles

- sales: Менеджер по продажам
- procurement: Менеджер по закупкам (по брендам)
- logistics: Логист
- customs: Менеджер ТО (Олег Князев)
- quote_controller: Контроллер КП (Жанна)
- spec_controller: Контроллер спецификаций
- finance: Финансовый менеджер
- top_manager: Топ-менеджер (согласования через Telegram)
- admin: Администратор

---
## Sessions

## Session 2025-01-15 - Feature #1: Создать таблицу roles
- Created SQL migration: `migrations/001_create_roles_table.sql`
- Table structure: id (UUID PK), code (VARCHAR UNIQUE), name, description, created_at
- Inserted all 9 predefined roles: sales, procurement, logistics, customs, quote_controller, spec_controller, finance, top_manager, admin
- Added RLS policy for read-only access by authenticated users
- Added index on code column for fast lookups
- Files changed: migrations/001_create_roles_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #2: Создать таблицу user_roles
- Created SQL migration: `migrations/002_create_user_roles_table.sql`
- Table structure:
  - id (UUID PK)
  - user_id (UUID FK → auth.users)
  - organization_id (UUID FK → organizations)
  - role_id (UUID FK → roles)
  - created_at (TIMESTAMP)
  - created_by (UUID FK → auth.users)
- Added unique constraint on (user_id, organization_id, role_id)
- Created indexes: user_id, organization_id, role_id, (user_id, organization_id) composite
- RLS policies:
  - Users can see their own roles
  - Users can see roles of others in their organization
  - Only admins can insert/delete roles
- Files changed: migrations/002_create_user_roles_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #3: Создать таблицу brand_assignments
- Created SQL migration: `migrations/003_create_brand_assignments_table.sql`
- Table structure:
  - id (UUID PK)
  - organization_id (UUID FK → organizations)
  - brand (VARCHAR 255) - matches brand field in quote_items
  - user_id (UUID FK → auth.users) - procurement manager assigned
  - created_at (TIMESTAMP)
  - created_by (UUID FK → auth.users)
- Unique constraint: (organization_id, brand) - one manager per brand per org
- Created indexes: user_id, organization_id, (organization_id, brand) composite
- RLS policies:
  - Users can view brand assignments in their organization
  - Only admins can insert/update/delete brand assignments
- Files changed: migrations/003_create_brand_assignments_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #4: Создать таблицу workflow_transitions
- Created SQL migration: `migrations/004_create_workflow_transitions_table.sql`
- Table structure:
  - id (UUID PK)
  - quote_id (UUID FK -> quotes, CASCADE DELETE)
  - from_status (VARCHAR 50) - previous workflow status
  - to_status (VARCHAR 50) - new workflow status
  - actor_id (UUID FK -> auth.users)
  - actor_role (VARCHAR 50) - role of actor at time of transition
  - comment (TEXT) - optional reason for transition
  - created_at (TIMESTAMP)
- Indexes created:
  - quote_id - for looking up transitions by quote
  - actor_id - for filtering by who made the change
  - to_status - for analytics on status transitions
  - (quote_id, created_at DESC) - for time-ordered history
- RLS policies:
  - Users can view transitions for quotes in their organization
  - Users can insert transitions for quotes in their organization
  - No UPDATE/DELETE - audit log is immutable
- Added table and column comments for documentation
- Files changed: migrations/004_create_workflow_transitions_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #5: Создать таблицу approvals
- Created SQL migration: `migrations/005_create_approvals_table.sql`
- Table structure:
  - id (UUID PK)
  - quote_id (UUID FK -> quotes, CASCADE DELETE)
  - requested_by (UUID FK -> auth.users) - who requested approval
  - approver_id (UUID FK -> auth.users) - who should approve
  - approval_type (VARCHAR 50) - default 'top_manager'
  - reason (TEXT) - why approval is needed
  - status (VARCHAR 20) - 'pending', 'approved', 'rejected' with CHECK constraint
  - decision_comment (TEXT) - comment from approver
  - requested_at (TIMESTAMP)
  - decided_at (TIMESTAMP) - set automatically via trigger
- Added CHECK constraint: decided_at must be NULL when pending, NOT NULL otherwise
- Created indexes:
  - quote_id - for finding approvals by quote
  - requested_by - for filtering by requester
  - approver_id - for finding approvals to review
  - status - for filtering by approval status
  - requested_at DESC - for time-ordered listing
  - (approver_id, status) composite - for pending approvals dashboard
- RLS policies:
  - Users can view approvals for quotes in their organization
  - Quote controllers can create approval requests
  - Approvers can update their pending approvals
  - No DELETE - approvals are immutable audit records
- Added trigger to automatically set decided_at when status changes from pending
- Files changed: migrations/005_create_approvals_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #6: Создать таблицу specifications
- Created SQL migration: `migrations/006_create_specifications_table.sql`
- Table structure with all 18+ fields from spec_controller:
  - id (UUID PK)
  - quote_id (UUID FK -> quotes, CASCADE DELETE)
  - quote_version_id (UUID FK -> quote_versions, SET NULL on delete)
  - organization_id (UUID FK -> organizations, CASCADE DELETE)
  - specification_number, proposal_idn, item_ind_sku (identification fields)
  - sign_date (DATE), validity_period (VARCHAR)
  - specification_currency, exchange_rate_to_ruble (currency fields)
  - client_payment_term_after_upd (INTEGER), client_payment_terms (TEXT)
  - cargo_pickup_country, readiness_period, goods_shipment_country (origin fields)
  - delivery_city_russia, cargo_type, logistics_period (delivery fields)
  - our_legal_entity, client_legal_entity (legal entities)
  - supplier_payment_country
  - signed_scan_url (TEXT for storing signed document URL)
  - status (VARCHAR with CHECK: draft, pending_review, approved, signed)
  - created_by, created_at, updated_at (audit fields)
- Indexes created:
  - quote_id - for finding specifications by quote
  - organization_id - for org-scoped queries
  - status - for filtering by status
  - created_at DESC - for time-ordered listing
  - specification_number - for lookups by number
  - (organization_id, status) composite - for org-scoped status filtering
- RLS policies:
  - Users can view specifications in their organization
  - Users can insert specifications in their organization
  - Users can update specifications in their organization
  - Only admins can delete specifications
- Added trigger for automatic updated_at timestamp
- All columns documented with COMMENT statements
- Files changed: migrations/006_create_specifications_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #7: Создать таблицу deals
- Created SQL migration: `migrations/007_create_deals_table.sql`
- Table structure:
  - id (UUID PK)
  - specification_id (UUID FK -> specifications, RESTRICT on delete)
  - quote_id (UUID FK -> quotes, RESTRICT on delete)
  - organization_id (UUID FK -> organizations, CASCADE on delete)
  - deal_number (VARCHAR 100) - human-readable identifier like DEAL-2025-0001
  - signed_at (DATE) - when specification was signed by client
  - total_amount (DECIMAL 15,2) - total deal amount
  - currency (VARCHAR 10) - RUB, USD, EUR, CNY
  - status (VARCHAR 20) - CHECK constraint: active, completed, cancelled
  - created_by, created_at, updated_at (audit fields)
- Indexes created:
  - specification_id, quote_id, organization_id (FK lookups)
  - status, signed_at DESC, deal_number (filtering & sorting)
  - created_at DESC (time-ordered listing)
  - (organization_id, status) composite for org-scoped queries
  - UNIQUE on specification_id (one deal per specification)
- RLS policies:
  - Users can view deals in their organization
  - Only spec_controller or admin can create deals
  - Only finance or admin can update deals
  - Only admin can delete deals
- Added trigger for automatic updated_at timestamp
- Added helper function generate_deal_number(org_id) for generating deal numbers
- Files changed: migrations/007_create_deals_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #8: Создать таблицу plan_fact_categories
- Created SQL migration: `migrations/008_create_plan_fact_categories_table.sql`
- Table structure:
  - id (UUID PK)
  - code (VARCHAR 50 UNIQUE) - category code for use in code
  - name (VARCHAR 255) - human-readable name in Russian
  - is_income (BOOLEAN) - true for income, false for expense
  - sort_order (INTEGER) - display order in UI
  - created_at (TIMESTAMP WITH TIME ZONE)
- Added indexes:
  - code - for fast lookups by code
  - is_income - for filtering income vs expense categories
  - sort_order - for ordered queries
- RLS policies:
  - All authenticated users can read categories (reference data)
  - Only admins can insert/update/delete categories
- Note: Seed data (Feature #15) commented out in migration file
- Files changed: migrations/008_create_plan_fact_categories_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #9: Создать таблицу plan_fact_items
- Created SQL migration: `migrations/009_create_plan_fact_items_table.sql`
- Table structure:
  - id (UUID PK)
  - deal_id (UUID FK -> deals, CASCADE on delete)
  - category_id (UUID FK -> plan_fact_categories, RESTRICT on delete)
  - description (TEXT) - payment description
  - planned_amount (DECIMAL 15,2), planned_currency, planned_date
  - actual_amount (DECIMAL 15,2 NULL), actual_currency, actual_date
  - actual_exchange_rate (DECIMAL 15,6) - exchange rate to RUB at payment date
  - variance_amount (DECIMAL 15,2) - calculated deviation in RUB
  - payment_document (VARCHAR 255) - payment reference number
  - notes (TEXT)
  - created_by, created_at, updated_at (audit fields)
- Indexes created:
  - deal_id, category_id (FK lookups)
  - planned_date, actual_date (date-based queries)
  - created_at DESC (time-ordered listing)
  - (deal_id, category_id), (deal_id, planned_date) composites
  - Partial index on unpaid items (actual_amount IS NULL)
- RLS policies:
  - Users can view plan_fact_items for deals in their organization
  - Only finance or admin can insert plan_fact_items
  - Only finance or admin can update plan_fact_items
  - Only admin can delete plan_fact_items
- Added trigger for automatic updated_at timestamp
- Added function calculate_plan_fact_variance() for automatic variance calculation
- Files changed: migrations/009_create_plan_fact_items_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #10: Создать таблицу telegram_users
- Created SQL migration: `migrations/010_create_telegram_users_table.sql`
- Table structure:
  - id (UUID PK)
  - user_id (UUID FK -> auth.users, CASCADE DELETE)
  - telegram_id (BIGINT UNIQUE) - Telegram user ID
  - telegram_username (VARCHAR 255) - username without @
  - is_verified (BOOLEAN) - whether account is verified
  - verification_code (VARCHAR 32) - temporary verification code
  - verification_code_expires_at (TIMESTAMP) - code expiration
  - created_at (TIMESTAMP)
  - verified_at (TIMESTAMP) - when account was verified
- Indexes created:
  - telegram_id (unique) - one Telegram per user
  - user_id - for lookup by user
  - verification_code (partial, where not verified) - for verification process
  - user_id (partial, where verified) - for sending notifications
- RLS policies:
  - Users can view/insert/update/delete their own Telegram link
  - Admins can view Telegram links of users in their organization
- Helper functions:
  - generate_telegram_verification_code() - generates 6-char random code
  - request_telegram_verification(user_id) - creates/updates verification code
  - verify_telegram_account(code, telegram_id, username) - verifies account
- Files changed: migrations/010_create_telegram_users_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #11: Создать таблицу notifications
- Created SQL migration: `migrations/011_create_notifications_table.sql`
- Table structure:
  - id (UUID PK)
  - user_id (UUID FK -> auth.users, CASCADE DELETE) - recipient
  - quote_id (UUID FK -> quotes, SET NULL) - related quote (nullable)
  - deal_id (UUID FK -> deals, SET NULL) - related deal (nullable)
  - type (VARCHAR 50) - notification type with CHECK constraint
  - title (VARCHAR 255) - notification title
  - message (TEXT) - full notification text
  - channel (VARCHAR 20) - delivery channel (telegram, email, in_app)
  - status (VARCHAR 20) - delivery status (pending, sent, delivered, read, failed)
  - telegram_message_id (BIGINT) - for updating Telegram messages
  - email_message_id (VARCHAR 255) - for email tracking
  - error_message (TEXT) - error details if failed
  - sent_at, delivered_at, read_at, created_at (TIMESTAMP WITH TIME ZONE)
- Notification types supported:
  - task_assigned, approval_required, approval_decision, status_changed
  - returned_for_revision, comment_added, deadline_reminder, system_message
- Indexes created:
  - user_id, quote_id (partial), deal_id (partial) - FK lookups
  - type, status, channel - filtering
  - created_at DESC - time-ordered listing
  - (user_id, status), (user_id, created_at DESC where unread) - dashboard queries
  - (channel, created_at where pending) - for notification sending queue
- RLS policies:
  - Users can view/update their own notifications
  - Users can insert notifications for users in their organization
- Helper functions:
  - create_notification() - creates new notification
  - mark_notification_sent() - marks as sent with message ID (service role)
  - mark_notification_failed() - marks as failed with error (service role)
  - mark_notification_read() - marks as read by user
  - get_pending_notifications() - gets pending notifications for channel (service role)
- Files changed: migrations/011_create_notifications_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #12: Расширить таблицу quotes
- Created SQL migration: `migrations/012_extend_quotes_table.sql`
- New columns added:
  - workflow_status (VARCHAR 50) - default 'draft', with CHECK constraint for 15 valid statuses
  - deal_type (VARCHAR 20) - 'supply' or 'transit', nullable
  - assigned_procurement_users (UUID[]) - array of procurement manager user IDs
  - assigned_logistics_user (UUID FK -> auth.users)
  - assigned_customs_user (UUID FK -> auth.users)
  - procurement_completed_at (TIMESTAMP WITH TIME ZONE)
  - logistics_completed_at (TIMESTAMP WITH TIME ZONE)
  - customs_completed_at (TIMESTAMP WITH TIME ZONE)
  - current_version_id (UUID FK -> quote_versions)
- Constraints added:
  - quotes_workflow_status_check - validates 15 workflow statuses
  - quotes_deal_type_check - validates 'supply' or 'transit'
  - FK constraints for assigned_logistics_user, assigned_customs_user, current_version_id
- Indexes created:
  - idx_quotes_workflow_status - for status filtering
  - idx_quotes_deal_type - for deal type filtering
  - idx_quotes_assigned_logistics_user (partial) - for logistics assignment queries
  - idx_quotes_assigned_customs_user (partial) - for customs assignment queries
  - idx_quotes_organization_workflow_status (composite) - for org+status filtering
  - idx_quotes_assigned_procurement_users (GIN) - for array membership search
- Existing quotes updated to have workflow_status = 'draft'
- Files changed: migrations/012_extend_quotes_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #13: Расширить таблицу quote_items
- Created SQL migration: `migrations/013_extend_quote_items_table.sql`
- New columns added:
  - assigned_procurement_user (UUID FK -> auth.users) - procurement manager for this item
  - procurement_status (VARCHAR 20) - 'pending', 'in_progress', 'completed'
  - procurement_completed_at (TIMESTAMP WITH TIME ZONE)
  - procurement_completed_by (UUID FK -> auth.users)
  - hs_code (VARCHAR 20) - customs HS code (ТН ВЭД)
  - customs_duty (DECIMAL 15,4) - duty percentage/amount
  - customs_extra (DECIMAL 15,2) - additional customs charges
- Constraints added:
  - quote_items_procurement_status_check - validates status values
- Indexes created:
  - idx_quote_items_assigned_procurement_user (partial)
  - idx_quote_items_procurement_status
  - idx_quote_items_procurement_user_status (composite, partial)
  - idx_quote_items_quote_procurement_status (composite)
- Helper functions added:
  - assign_procurement_user_by_brand() - trigger function for auto-assignment
  - complete_item_procurement(item_id, user_id) - marks item procurement complete
  - check_quote_procurement_complete(quote_id) - checks if all items are done
- Trigger: trigger_assign_procurement_user - auto-assigns procurement user based on brand
- Files changed: migrations/013_extend_quote_items_table.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #14: Заполнить справочник roles
- NOTE: Already completed as part of Feature #1
- Roles seed data was included in migrations/001_create_roles_table.sql
- All 9 roles (sales, procurement, logistics, customs, quote_controller, spec_controller, finance, top_manager, admin) already inserted
- Status: COMPLETE (no additional work needed)

## Session 2025-01-15 - Feature #15: Заполнить справочник plan_fact_categories
- Created SQL migration: `migrations/014_seed_plan_fact_categories.sql`
- Inserted 7 payment categories:
  - client_payment (income) - Оплата от клиента
  - supplier_payment (expense) - Оплата поставщику
  - logistics (expense) - Логистика
  - customs (expense) - Таможня
  - tax (expense) - Налоги
  - finance_commission (expense) - Банковская комиссия
  - other (expense) - Прочее
- Used UPSERT pattern (ON CONFLICT DO UPDATE) for idempotency
- Added documentation comments for each category
- Files changed: migrations/014_seed_plan_fact_categories.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #16: Настроить RLS для новых таблиц
- Verified that all 11 new tables have RLS enabled and policies configured
- RLS was already set up in each table's individual migration file:
  - 001: roles - SELECT for all authenticated users
  - 002: user_roles - SELECT own/org, INSERT/DELETE admin only
  - 003: brand_assignments - full CRUD with org/admin restrictions
  - 004: workflow_transitions - SELECT/INSERT for org quotes (immutable)
  - 005: approvals - SELECT org, INSERT quote_controller, UPDATE approver
  - 006: specifications - SELECT/INSERT/UPDATE org, DELETE admin
  - 007: deals - SELECT org, INSERT spec_controller, UPDATE finance
  - 008: plan_fact_categories - SELECT all, write admin only
  - 009: plan_fact_items - SELECT org, INSERT/UPDATE finance
  - 010: telegram_users - own record access
  - 011: notifications - SELECT/UPDATE own, INSERT org
- Created verification migration: migrations/015_verify_rls_policies.sql
- Added helper functions:
  - user_has_role_in_org(user_id, org_id, role_codes[]) - check role membership
  - user_organization_ids(user_id) - get user's organizations
  - user_is_admin_in_org(org_id) - check admin role
- Added comprehensive RLS policy documentation
- Files changed: migrations/015_verify_rls_policies.sql (new)
- Status: COMPLETE

## Session 2025-01-15 - Feature #17: Сервис ролей: получение ролей пользователя
- Created new service file: services/role_service.py
- Implemented functions:
  - get_user_roles(user_id, org_id) → List[Role] - main function for getting user roles
  - get_user_role_codes(user_id, org_id) → List[str] - convenience function for role codes only
  - get_all_roles() → List[Role] - get all available roles
  - get_role_by_code(code) → Optional[Role] - get single role by code
  - get_users_by_role(org_id, role_code) → List[dict] - get users with specific role
  - get_users_by_any_role(org_id, role_codes) → List[dict] - get users with any of specified roles
- Created dataclasses:
  - Role: id, code, name, description
  - UserRole: id, user_id, organization_id, role, created_at, created_by
- Updated services/__init__.py to export new functions
- Tested imports successfully
- Files changed:
  - services/role_service.py (new)
  - services/__init__.py (updated)
- Status: COMPLETE

## Session 2025-01-15 - Feature #18: Сервис ролей: проверка наличия роли
- Implemented three role-checking functions in services/role_service.py:
  - has_role(user_id, org_id, role_code) → bool - check for single role
  - has_any_role(user_id, org_id, role_codes) → bool - check for any of multiple roles
  - has_all_roles(user_id, org_id, role_codes) → bool - check for all specified roles
- All functions use get_user_role_codes internally for efficiency
- Updated services/__init__.py to export new functions
- Verified no syntax errors
- These functions enable role-based access control throughout the application
- Files changed:
  - services/role_service.py (updated)
  - services/__init__.py (updated)
- Status: COMPLETE

## Session 2025-01-15 - Feature #19: Сервис ролей: назначение роли
- Implemented assign_role function in services/role_service.py:
  - assign_role(user_id, org_id, role_code, assigned_by) → Optional[UserRole]
  - Creates new user_role record in database
  - Returns UserRole object if successful, None if user already has role or invalid role_code
  - Prevents duplicate role assignments by checking with has_role first
  - Uses get_role_by_code to validate and get role ID
- Function is idempotent - safe to call multiple times
- Full documentation with docstrings and examples
- Updated services/__init__.py to export assign_role
- Verified no syntax errors
- Files changed:
  - services/role_service.py (updated)
  - services/__init__.py (updated)
- Status: COMPLETE

## Session 2025-01-15 - Feature #20: Сервис ролей: удаление роли
- Implemented remove_role function in services/role_service.py:
  - remove_role(user_id, org_id, role_code) → bool
  - Deletes user_role record from database
  - Returns True if role was removed, False if user didn't have role or invalid role_code
  - Validates that user has the role before attempting deletion
  - Uses get_role_by_code to get role ID for deletion
- Function complements assign_role for complete role management
- Full documentation with docstrings and examples
- Updated services/__init__.py to export remove_role
- Verified no syntax errors
- Files changed:
  - services/role_service.py (updated)
  - services/__init__.py (updated)
- Status: COMPLETE

## Session 2025-01-15 - Feature #21: Middleware require_role
- Implemented four route protection middleware functions in services/role_service.py:
  - require_role(session, role_code) → checks for single role
  - require_any_role(session, role_codes) → checks for any of multiple roles
  - require_all_roles(session, role_codes) → checks for all specified roles
  - get_session_user_roles(session) → convenience function to get user's roles
- All middleware functions:
  - Return RedirectResponse to /login if not logged in
  - Return RedirectResponse to /unauthorized if missing required role(s)
  - Return None if access is granted
- Added /unauthorized route in main.py:
  - Shows user-friendly "Access Denied" page
  - Provides link back to dashboard
- Follows FastHTML pattern: `if redirect := require_role(session, 'admin'): return redirect`
- Full docstrings with usage examples
- Updated services/__init__.py to export all new functions
- Verified no syntax errors
- Files changed:
  - services/role_service.py (updated)
  - services/__init__.py (updated)
  - main.py (updated - added /unauthorized route)
- Status: COMPLETE

## Session 2025-01-15 - Feature #22: Контекст пользователя с ролями
- Extended session["user"] to include roles at login time
- Modified login POST handler in main.py:
  - After getting org_id, calls get_user_role_codes(user_id, org_id)
  - Stores roles as list in session["user"]["roles"]
- Added role service imports to main.py:
  - get_user_role_codes, get_session_user_roles, require_role, require_any_role
- Added session-based helper functions in main.py:
  - user_has_role(session, role_code) → bool
  - user_has_any_role(session, role_codes) → bool
  - get_user_roles_from_session(session) → list
- These helpers check roles from session cache (no database query)
- Session structure now:
  ```python
  session["user"] = {
      "id": user_id,
      "email": email,
      "org_id": org_id,
      "org_name": org_name,
      "roles": ["sales", "admin", ...]  # NEW
  }
  ```
- Verified no syntax errors
- Files changed:
  - main.py (updated)
- Status: COMPLETE

## Session 2025-01-15 - Feature #23: Enum статусов workflow
- Created new service file: services/workflow_service.py
- Implemented WorkflowStatus enum with all 15 workflow statuses:
  - DRAFT, PENDING_PROCUREMENT, PENDING_LOGISTICS, PENDING_CUSTOMS
  - PENDING_SALES_REVIEW, PENDING_QUOTE_CONTROL, PENDING_APPROVAL, APPROVED
  - SENT_TO_CLIENT, CLIENT_NEGOTIATION, PENDING_SPEC_CONTROL, PENDING_SIGNATURE
  - DEAL, REJECTED, CANCELLED
- Created StatusTransition dataclass for defining allowed transitions
- Implemented complete transition matrix (ALLOWED_TRANSITIONS list):
  - Defines who can transition from what status to what status
  - Each transition has: from_status, to_status, allowed_roles, requires_comment, auto_transition
  - 26 total transitions defined covering all workflow paths
- Added metadata dictionaries:
  - STATUS_NAMES: Full Russian names for each status
  - STATUS_NAMES_SHORT: Short names for compact display
  - STATUS_COLORS: Tailwind CSS classes for status badges
  - IN_PROGRESS_STATUSES: Set of active statuses
  - FINAL_STATUSES: Set of terminal statuses (deal, rejected, cancelled)
- Implemented helper functions:
  - get_status_name(status) → Russian name
  - get_status_name_short(status) → Short name
  - get_status_color(status) → Tailwind CSS classes
  - get_allowed_transitions(current_status, user_roles) → List[StatusTransition]
  - get_allowed_target_statuses(current_status, user_roles) → List[WorkflowStatus]
  - can_transition(current_status, target_status, user_roles) → (bool, error_message)
  - is_final_status(status) → bool
  - is_in_progress(status) → bool
  - get_workflow_order() → ordered list for progress bar
  - get_workflow_stage(status) → numeric stage (0-12)
  - get_all_statuses() → list for UI dropdowns
- Updated services/__init__.py to export all new functions
- Verified syntax with py_compile
- Files changed:
  - services/workflow_service.py (new)
  - services/__init__.py (updated)
- Status: COMPLETE

## Session 2025-01-15 - Feature #24: Матрица переходов статусов
- Extended workflow_service.py with permission matrix functions:
  - get_transition_requirements(from, to) → StatusTransition - Get requirements for specific transition
  - get_roles_for_transition(from, to) → List[str] - Get roles that can perform transition
  - get_transitions_by_role(role_code) → List[Dict] - Get all transitions a role can perform
  - get_permission_matrix() → Dict - Complete nested dict for UI {from: {to: [roles]}}
  - get_permission_matrix_detailed() → List[Dict] - Full details for table display
  - get_outgoing_transitions(status) → List[Dict] - All possible destinations from status
  - get_incoming_transitions(status) → List[Dict] - All possible sources to status
  - is_comment_required(from, to) → bool - Check if transition needs comment
  - is_auto_transition(from, to) → bool - Check if transition is automatic
- Updated services/__init__.py to export all new functions
- All functions handle both WorkflowStatus enum and string status codes
- Verified syntax with py_compile
- Files changed:
  - services/workflow_service.py (updated - added ~250 lines)
  - services/__init__.py (updated)
- Status: COMPLETE

## Session 2025-01-15 - Feature #25: Сервис перехода статуса
- Implemented transition_quote_status() - the main function for executing workflow transitions
  - Takes: quote_id, to_status, actor_id, actor_roles, comment (optional), skip_validation (optional)
  - Returns: TransitionResult dataclass with success/error info
  - Steps: Fetch quote → Validate transition → Check comment required → Update quote → Log transition
  - Handles errors gracefully, returns meaningful error messages
- Added TransitionResult dataclass for structured return values
- Implemented helper functions:
  - get_quote_workflow_status(quote_id) → Optional[WorkflowStatus] - Get current status of a quote
  - get_quote_transition_history(quote_id, limit) → List[Dict] - Get audit log of transitions
  - get_available_transitions_for_quote(quote_id, user_roles) → List[Dict] - Get available transitions for UI
- All functions:
  - Use Supabase service role for database access
  - Handle both string and enum status values
  - Include comprehensive docstrings and examples
- Updated services/__init__.py to export all new functions
- Verified imports successfully in venv
- Files changed:
  - services/workflow_service.py (updated - added ~350 lines)
  - services/__init__.py (updated)
- Status: COMPLETE

## Session 2025-01-15 - Features #26-27: Validation and Logging
- NOTE: These features were already implemented within Feature #25:
  - Feature #26 (Validation): can_transition() validates roles and status transitions
  - Feature #27 (Logging): transition_quote_status() Step 5 logs to workflow_transitions
- Marked both features as complete in features.json
- Status: COMPLETE (no additional code needed)

## Session 2025-01-15 - Feature #28: Auto-transition logistics+customs → sales_review
- Implemented auto-transition logic when both parallel stages complete
- New functions in workflow_service.py:
  - check_and_auto_transition_to_sales_review(quote_id, actor_id)
    - Checks if both logistics_completed_at and customs_completed_at are set
    - If both complete, auto-transitions to pending_sales_review
    - Uses skip_validation=True for system-initiated transitions
  - complete_logistics(quote_id, actor_id, actor_roles)
    - Validates logistics/admin role
    - Sets logistics_completed_at timestamp
    - Logs completion to workflow_transitions
    - Calls auto-transition check
    - Returns TransitionResult with new status (if auto-transitioned)
  - complete_customs(quote_id, actor_id, actor_roles)
    - Same pattern as complete_logistics for customs role
    - Sets customs_completed_at timestamp
    - Triggers auto-transition if logistics also complete
  - get_parallel_stages_status(quote_id)
    - Returns dict with completion status of both stages
    - Useful for UI progress indicators
- All functions:
  - Properly validate current workflow status
  - Prevent double-completion
  - Include comprehensive docstrings
- Updated services/__init__.py to export all new functions
- Verified imports successfully in venv
- Files changed:
  - services/workflow_service.py (updated - added ~420 lines)
  - services/__init__.py (updated)
- Status: COMPLETE
